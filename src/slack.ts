import type { SprintSummary } from "./schema";

export interface SlackMessage {
  text: string;
  blocks?: unknown[];
}

export function buildSlackPayload(summary: SprintSummary): SlackMessage {
  const { sprint, metrics, notes } = summary;
  const dateRange = `${sprint.start_date}〜${sprint.end_date}`;
  const metricLines =
    metrics.length > 0
      ? metrics.map((m) => `• ${m.key}: ${m.value}`).join("\n")
      : "• (no metrics)";
  const noteLines =
    notes.length > 0 ? notes.map((n) => `• ${n}`).join("\n") : "• (no notes)";

  const text = `【Sprint Report】${sprint.name}（${dateRange}）\nStatus: ${sprint.status}\n\n${metricLines}\n\nNotes:\n${noteLines}\n\n(Generated by Notion MCP + Worker Cron)`;

  return {
    text,
    blocks: [
      {
        type: "header",
        text: {
          type: "plain_text",
          text: `Sprint Report: ${sprint.name}`,
          emoji: true
        }
      },
      {
        type: "section",
        fields: [
          { type: "mrkdwn", text: `*期間*\n${dateRange}` },
          { type: "mrkdwn", text: `*ステータス*\n${sprint.status}` }
        ]
      },
      {
        type: "section",
        text: { type: "mrkdwn", text: "*メトリクス*\n" + metricLines }
      },
      {
        type: "section",
        text: { type: "mrkdwn", text: "*Notes*\n" + noteLines }
      },
      {
        type: "context",
        elements: [
          {
            type: "mrkdwn",
            text: "Generated by Notion MCP + Worker Cron"
          }
        ]
      }
    ]
  };
}

interface TaskItem {
  id: string;
  title: string;
  status?: string;
  period?: { start?: string | null; end?: string | null };
  planSp?: number | null;
  doneSp?: number | null;
  progressSp?: number | null;
}

export function buildTasksPayload(
  tasks: TaskItem[],
  range: { start: string; end: string }
): SlackMessage {
  const title = `Sprint Tasks ${range.start}〜${range.end}`;
  const lines =
    tasks.length === 0
      ? ["• 該当タスクなし"]
      : tasks.map((t) => {
          const period =
            t.period?.start || t.period?.end
              ? `${t.period?.start ?? ""}〜${t.period?.end ?? ""}`
              : "-";
          const status = t.status ?? "-";
          const plan = t.planSp ?? "-";
          const done = t.doneSp ?? "-";
          const prog = t.progressSp ?? "-";
          return `• ${t.title} | 状態:${status} | 期間:${period} | 計画SP:${plan} | 完了SP:${done} | 進捗SP:${prog}`;
        });

  const text = [title, ...lines].join("\n");
  return {
    text,
    blocks: [
      {
        type: "header",
        text: { type: "plain_text", text: title, emoji: false }
      },
      {
        type: "section",
        text: {
          type: "mrkdwn",
          text: `件数: ${tasks.length}`
        }
      },
      {
        type: "section",
        text: { type: "mrkdwn", text: lines.join("\n") }
      }
    ]
  };
}

interface AssigneeTask {
  id: string;
  name: string;
  status?: string | null;
  priority?: string | null;
  sp?: number | null;
  due?: string | null;
  url?: string | null;
}

interface AssigneeGroup {
  name: string;
  tasks: AssigneeTask[];
}

export function buildSprintTasksPayload(
  summary: {
    sprint: { name: string; start_date: string; end_date: string };
    assignees: AssigneeGroup[];
  },
  metrics: {
    planSp: number | null;
    progressSp: number | null;
    remainingSp: number | null;
    requiredSpPerDay: number | null;
  },
  changes: {
    totalProgressSp: number;
    items: string[];
  }
): SlackMessage {
  const dateRange = `${summary.sprint.start_date}〜${summary.sprint.end_date}`;
  const header = `Sprint Tasks: ${summary.sprint.name}`;
  const metricLines = [
    `全体SP: ${metrics.planSp ?? "-"}`,
    `進捗SP: ${metrics.progressSp ?? "-"}`,
    `残りSP: ${metrics.remainingSp ?? "-"}`,
    `残りSP/日: ${metrics.requiredSpPerDay ?? "-"}`
  ].join(" | ");

  const lines = summary.assignees.length
    ? summary.assignees.flatMap((assignee) => {
        const items = assignee.tasks.length
          ? assignee.tasks.map((task) => {
              const status = task.status ?? "-";
              const priority = task.priority ?? "-";
              const sp = task.sp ?? "-";
              const due = task.due ?? "-";
              return `• ${task.name} | 状態:${status} | 優先度:${priority} | SP:${sp} | 期限:${due}`;
            })
          : ["• (タスクなし)"];
        return [`*${assignee.name}*`, ...items];
      })
    : ["• 担当者が見つかりませんでした"];

  const changeLines = changes.items.length
    ? changes.items
    : ["• 昨日からの変更なし"];
  const text = [
    header,
    `期間: ${dateRange}`,
    metricLines,
    `昨日からの進捗SP合計: ${changes.totalProgressSp}`,
    ...changeLines,
    ...lines
  ].join("\n");

  return {
    text,
    blocks: [
      {
        type: "header",
        text: { type: "plain_text", text: header, emoji: false }
      },
      {
        type: "section",
        fields: [
          { type: "mrkdwn", text: `*期間*\n${dateRange}` },
          { type: "mrkdwn", text: `*SP*\n${metricLines}` }
        ]
      },
      {
        type: "section",
        text: {
          type: "mrkdwn",
          text: `*昨日からの進捗SP合計*\n${changes.totalProgressSp}`
        }
      },
      {
        type: "section",
        text: { type: "mrkdwn", text: changeLines.join("\n") }
      },
      {
        type: "section",
        text: { type: "mrkdwn", text: lines.join("\n") }
      }
    ]
  };
}

export function buildAssigneeTasksPayload(
  summary: {
    sprint: { name: string; start_date: string; end_date: string };
    assignees: AssigneeGroup[];
  },
  meta?: {
    metrics: {
      planSp: number | null;
      progressSp: number | null;
      remainingSp: number | null;
      requiredSpPerDay: number | null;
    };
    changes: {
      totalProgressSp: number;
      items: string[];
    };
  }
): SlackMessage {
  const dateRange = `${summary.sprint.start_date}〜${summary.sprint.end_date}`;
  const header = `Sprint Tasks: ${summary.sprint.name}`;

  const formatDue = (value?: string | null): string => {
    if (!value) return "-";
    const [_y, m, d] = value.split("-");
    if (!m || !d) return value;
    return `${Number(m)}/${Number(d)}`;
  };

  const formatStatus = (value?: string | null): string => {
    if (!value) return "-";
    const match = value.match(/doing\s*\((\d{1,3})\s*%?\)/i);
    if (match?.[1]) return `${match[1]}%`;
    return value;
  };

  const formatOneDecimal = (value: number | null): string => {
    if (typeof value !== "number" || Number.isNaN(value)) return "-";
    return value.toFixed(1);
  };

  const stringWidth = (value: string): number => {
    let width = 0;
    for (const ch of value) {
      const code = ch.codePointAt(0) ?? 0;
      if (code <= 0x1f || code === 0x7f) continue;
      width += code <= 0x7e ? 1 : 2;
    }
    return width;
  };

  const trimToWidth = (value: string, maxWidth: number): string => {
    if (stringWidth(value) <= maxWidth) return value;
    if (maxWidth <= 3) return value.slice(0, maxWidth);
    let out = "";
    let width = 0;
    for (const ch of value) {
      const code = ch.codePointAt(0) ?? 0;
      const w = code <= 0x7e ? 1 : 2;
      if (width + w > maxWidth - 3) break;
      out += ch;
      width += w;
    }
    return out + "...";
  };

  const padRight = (value: string, width: number): string => {
    const trimmed = trimToWidth(value, width);
    const pad = width - stringWidth(trimmed);
    return trimmed + " ".repeat(Math.max(0, pad));
  };

  const buildTable = (rows: Array<{ name: string; status: string; priority: string; sp: string; due: string }>): string => {
    const dataRows = rows.length
      ? rows
      : [{ name: "(タスクなし)", status: "-", priority: "-", sp: "-", due: "-" }];

    const columns = [
      { label: "タスク名", key: "name", maxWidth: 48 },
      { label: "ステータス", key: "status", maxWidth: 10 },
      { label: "優先度", key: "priority", maxWidth: 6 },
      { label: "SP", key: "sp", maxWidth: 6 },
      { label: "期限", key: "due", maxWidth: 8 }
    ] as const;

    const widths = columns.map((col) => {
      const maxValueWidth = Math.max(
        stringWidth(col.label),
        ...dataRows.map((row) => stringWidth(row[col.key]))
      );
      return Math.min(col.maxWidth, maxValueWidth);
    });

    const headerLine = columns
      .map((col, i) => padRight(col.label, widths[i]))
      .join("  ");
    const separatorLine = widths.map((w) => "-".repeat(w)).join("  ");
    const rowLines = dataRows.map((row) =>
      columns
        .map((col, i) => padRight(row[col.key], widths[i]))
        .join("  ")
    );

    return ["```text", headerLine, separatorLine, ...rowLines, "```"].join(
      "\n"
    );
  };

  const lines = summary.assignees.length
    ? summary.assignees.flatMap((assignee, index) => {
        const rows = assignee.tasks.map((task) => ({
          name: task.name,
          status: formatStatus(task.status),
          priority: task.priority ?? "-",
          sp: task.sp != null ? String(task.sp) : "-",
          due: formatDue(task.due)
        }));
        const table = buildTable(rows);
        const block = [`*${assignee.name}*`, table];
        if (index === summary.assignees.length - 1) return block;
        return [...block, ""];
      })
    : ["担当者が見つかりませんでした"];

  const metaLines: string[] = [];
  if (meta) {
    const metricLine = [
      `全体SP: ${formatOneDecimal(meta.metrics.planSp)}`,
      `進捗SP: ${formatOneDecimal(meta.metrics.progressSp)}`,
      `残りSP: ${formatOneDecimal(meta.metrics.remainingSp)}`,
      `残りSP/日: ${formatOneDecimal(meta.metrics.requiredSpPerDay)}`
    ].join(" | ");
    const changeLines = meta.changes.items.length
      ? meta.changes.items
      : ["• 昨日からの変更なし"];
    metaLines.push(
      "",
      "SP",
      metricLine,
      "昨日からの進捗SP合計",
      formatOneDecimal(meta.changes.totalProgressSp),
      ...changeLines
    );
  }

  const text = [header, `期間: ${dateRange}`, ...lines, ...metaLines].join(
    "\n"
  );

  const metaBlocks: unknown[] = meta
    ? [
        {
          type: "section",
          text: {
            type: "mrkdwn",
            text: [
              "*SP*",
              [
                `全体SP: ${formatOneDecimal(meta.metrics.planSp)}`,
                `進捗SP: ${formatOneDecimal(meta.metrics.progressSp)}`,
                `残りSP: ${formatOneDecimal(meta.metrics.remainingSp)}`,
                `残りSP/日: ${formatOneDecimal(
                  meta.metrics.requiredSpPerDay
                )}`
              ].join(" | "),
              "*昨日からの進捗SP合計*",
              formatOneDecimal(meta.changes.totalProgressSp),
              ...(meta.changes.items.length
                ? meta.changes.items
                : ["• 昨日からの変更なし"])
            ].join("\n")
          }
        }
      ]
    : [];

  return {
    text,
    blocks: [
      {
        type: "header",
        text: { type: "plain_text", text: header, emoji: false }
      },
      {
        type: "section",
        fields: [{ type: "mrkdwn", text: `*期間*\n${dateRange}` }]
      },
      {
        type: "section",
        text: { type: "mrkdwn", text: lines.join("\n") }
      },
      ...metaBlocks
    ]
  };
}

export async function postSlack(
  webhookUrl: string,
  message: SlackMessage
): Promise<void> {
  const res = await fetch(webhookUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(message)
  });
  if (!res.ok) {
    const body = await res.text();
    throw new Error(`Slack webhook failed: ${res.status} ${body}`);
  }
}
